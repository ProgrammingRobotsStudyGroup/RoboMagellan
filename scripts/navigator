#! /usr/bin/env python

"""Implements navigation for the Robo Magellan rover."""

import time
from math import pi, tan, atan2, sqrt
import rospy
import std_msgs.msg as std_msgs
from std_msgs.msg import Bool
from geometry_msgs.msg import Pose, PoseStamped, Twist, TwistStamped
from mavros_msgs.msg import State, OverrideRCIn, ParamValue, WaypointList
from mavros_msgs.srv import ParamGet, ParamSet, SetMode, CommandBool
from mavros_msgs.srv import WaypointSetCurrent
from robo_magellan.msg import location_msgs as location_data


class Modes:
    MANUAL = 'MANUAL'
    HOLD = 'HOLD'
    AUTO = 'AUTO'
    GUIDED = 'GUIDED'
    RTL = 'RTL'

class MavrosCmds:
    MAV_CMD_DO_CHANGE_SPEED = 178
    MAV_CMD_DO_SET_HOME = 179


class ExecCmds:
    START = 'START_EXEC'
    RESET = 'RESET'


class Topics:
    WAYPOINTS = '/mavros/mission/waypoints'
    SET_CURRENT_WAYPOINT = '/mavros/mission/set_current'
    RC_OVERRIDE = '/mavros/rc/override'
    SETPOINT_VELOCITY = '/mavros/setpoint_velocity/cmd_vel'
    GET_PARAM = '/mavros/param/get'
    SET_PARAM = '/mavros/param/set'
    ARMING = '/mavros/cmd/arming'
    SET_MODE = '/mavros/set_mode'
    ROBOT_POSE = '/mavros/local_position/pose'
    ROBOT_STATE = '/mavros/state'
    CONE_LOCATIONS = '/robo_magellan/cone_finder/locations'
    EXEC_CMD = '/exec_cmd_simple'
    TOUCH = '/robo_magellan/touch'
    NAVIGATOR_STATE = '~state'


class RCChannels:
    SPEED = 2
    TURNING = 0


class NavigatorState:

    def __init__(self, name):
        self.name = name

    def get_name(self):
        return self.name


class States:
    WAITING_FOR_START = NavigatorState('WAITING_FOR_START')
    FOLLOWING_WAYPOINTS = NavigatorState('FOLLOWING_WAYPOINTS')
    EXPECTING_CONE = NavigatorState('EXPECTING_CONE')
    DRIVING_TO_CONE = NavigatorState('DRIVING_TO_CONE')
    ESCAPING_CONE = NavigatorState('ESCAPING_CONE')
    FINISHED = NavigatorState('FINISHED')
    FAILED = NavigatorState('FAILED')


class Navigator:

    def run(self):
        self.state = None
        self.last_wp_speed = None
        self.state_timer = None
        self.cone_wp_index = -1
        self.cone_pose = None
        self.waypoint_list = WaypointList()
        self.waypoint_list.waypoints = []

        rospy.init_node('navigator')

        rate = rospy.Rate(rospy.get_param('~rate', 10))

        self.fast_speed = rospy.get_param('~fast_speed', 3.0)
        self.slow_speed = rospy.get_param('~slow_speed', 1.5)
        self.cone_approach_k_speed = rospy.get_param('~cone_approach_k_speed', 0.25)
        self.cone_approach_min_speed = rospy.get_param('~cone_min_approach_speed', 0.25)
        self.cone_approach_k_heading = rospy.get_param('~cone_approach_k_heading', 2.0)
        self.cone_timeout = rospy.get_param('~cone_timeout_seconds', 60)

        self.camera_horz_fov = rospy.get_param('~horz_fov', 70.0) / 180.0 * pi
        self.camera_horz_pixels = rospy.get_param('~horz_pixels', 640)

        self.rc_pub = rospy.Publisher(Topics.RC_OVERRIDE, OverrideRCIn,
                                      queue_size=1)

        self.vel_pub = rospy.Publisher(Topics.SETPOINT_VELOCITY,
                                       TwistStamped, queue_size=1)

        self.state_pub = rospy.Publisher(Topics.NAVIGATOR_STATE,
                                         std_msgs.String, queue_size=1,
                                         latch=True)

        rospy.Subscriber(Topics.EXEC_CMD, std_msgs.String, self.on_exec_cmd)
        rospy.Subscriber(Topics.ROBOT_STATE, State, self.on_state)
        rospy.Subscriber(Topics.WAYPOINTS, WaypointList,
                         self.on_waypoints_changed)
        rospy.Subscriber(Topics.ROBOT_POSE, PoseStamped, self.on_xyz_position)
        rospy.Subscriber(Topics.CONE_LOCATIONS, location_data,
                         self.on_cone_locations)
        rospy.Subscriber(Topics.TOUCH, Bool, self.on_touch)

        self._set_mode = self.get_proxy(Topics.SET_MODE, SetMode)
        self._param_get = self.get_proxy(Topics.GET_PARAM, ParamGet)
        self._param_set = self.get_proxy(Topics.SET_PARAM, ParamSet)
        self._mavros_arming = self.get_proxy(Topics.ARMING, CommandBool)
        self._mavros_set_current_wp = self.get_proxy(
            Topics.SET_CURRENT_WAYPOINT, WaypointSetCurrent)

        self.last_wp_speed = self._param_get('WP_SPEED')

        # If gcs_id is set, set SYSID_MYGCS parameter.
        if rospy.has_param("~gcs_id"):
            gcs_id = int(rospy.get_param("~gcs_id"))
            param = ParamValue()
            param.integer = gcs_id
            self._param_set('SYSID_MYGCS', param)

        self.begin_state(States.WAITING_FOR_START)

        while not rospy.is_shutdown():
            self.state_pub.publish(self.state.get_name())
            rate.sleep()

    def get_proxy(self, topic, type):
        rospy.wait_for_service(topic)
        return rospy.ServiceProxy(topic, type)

    def set_timer(self, timeout, callback):
        self.cancel_timer()
        self.state_timer = rospy.Timer(rospy.Duration(timeout), callback,
                                       oneshot=True)

    def cancel_timer(self):
        if self.state_timer is not None:
            self.state_timer.shutdown()
            self.state_timer = None

    def begin_state(self, new_state):
        old_state = self.state
        self.state = new_state
        if old_state is None:
            rospy.loginfo('Initial state: %s', new_state.get_name())
        else:
            rospy.loginfo('State change: %s --> %s', old_state.get_name(),
                          new_state.get_name())

    def show_event(self, event, value=None):
        if self.state is None:
            rospy.loginfo('No state, event: %s', event)
        elif value is None:
            rospy.loginfo('In state %s, event: %s', self.state.get_name(),
                          event)
        else:
            rospy.loginfo('In state %s, event: %s, value: %s',
                          self.state.get_name(), event, value)

    def on_exec_cmd(self, msg):
        cmd = msg.data

        if self.state is States.WAITING_FOR_START and cmd==ExecCmds.START:
            self.show_event('on_exec_cmd', cmd)
            # Make sure we have waypoints.
            if len(self.waypoint_list.waypoints) == 0:
                rospy.logerr('No waypoints loaded')
                return
            # Adjust waypoints w/ wp index zero and start following
            # waypoints.
            self._mavros_set_current_wp(0) # For now, just set waypoint index
            self._mavros_arming(True)
            rospy.sleep(1.0)
            self.set_waypoint_speed()
            self.begin_state(States.FOLLOWING_WAYPOINTS)
        elif self.state is States.FINISHED and cmd==ExecCmds.RESET:
            self.show_event('on_exec_cmd', cmd)
            self.begin_state(States.WAITING_FOR_START)
        elif self.state is States.FAILED and cmd==ExecCmds.RESET:
            self.show_event('on_exec_cmd', cmd)
            self.begin_state(States.WAITING_FOR_START)

    def on_state(self, state):
        if self.state is States.EXPECTING_CONE and state.mode==Modes.HOLD:
            self.show_event('on_state', state.mode)
            self.cancel_timer()
            self.begin_state(States.FAILED)

    def on_xyz_position(self, position):
        if self.state is States.ESCAPING_CONE:
            self.show_event('on_xyz_position')
            # Should check to see if achieved desired heading. For now,
            # just assume cone is cleared. Change state first,
            # because waypoints may come in before the call returns.
            # (An exception to our usual rule.)
            self.set_mode(Modes.HOLD)
            self._mavros_set_current_wp(self.cone_wp_index + 1)
            rospy.sleep(1.0)
            self.set_waypoint_speed()
            self.begin_state(States.FOLLOWING_WAYPOINTS)

    def on_waypoints_changed(self, waypoint_list):
        self.waypoint_list = waypoint_list
        if len(self.waypoint_list.waypoints) == 0:
            rospy.logerr('No waypoints loaded')
            return

        if self.state is States.FOLLOWING_WAYPOINTS \
             and self.is_cone_waypoint(self.waypoint_list.current_seq):
            self.show_event('on_waypoints_changed')
            self.cone_wp_index = self.waypoint_list.current_seq
            self.set_waypoint_speed()
            self.set_timer(self.cone_timeout,  self.on_timeout_finding_cone)
            self.begin_state(States.EXPECTING_CONE)
        elif self.state is States.FOLLOWING_WAYPOINTS:
            self.show_event('on_waypoints_changed')
            self.set_waypoint_speed()

    def on_touch(self, msg):
        touching = msg.data

        if self.state is States.DRIVING_TO_CONE and touching:
            self.show_event('on_touch', touching)
            self.state_timer.shutdown()
            self.state_timer = None
            self.set_mode(Modes.HOLD)
            if self.cone_wp_index == len(self.waypoint_list.waypoints)-1:
                self.begin_state(States.FINISHED)
            else:
                # Should update waypoints and set index, but for now
                # just set index.
                self._mavros_set_current_wp(self.cone_wp_index + 1)
                rospy.sleep(1.0)
                self.begin_state(States.ESCAPING_CONE)

    def on_timeout_finding_cone(self, event):
        self.state_timer = None
        if self.cone_wp_index == len(self.waypoint_list.waypoints)-1:
            self.show_event('on_timeout_finding_cone')
            # Timeout on last waypoint.
            self.set_mode(Modes.HOLD)
            self.begin_state(States.FAILED)
        else:
            self.show_event('on_timeout_finding_cone')
            # Timeout, not last cone.
            self.set_mode(Modes.HOLD)
            self._mavros_set_current_wp(self.cone_wp_index + 1)
            rospy.sleep(1.0)
            self.set_waypoint_speed()
            self.begin_state(States.FOLLOWING_WAYPOINTS)

    def on_cone_locations(self, cone_locations):
        if self.state is States.EXPECTING_CONE \
           and len(cone_locations.poses) > 0:
            self.show_event('on_cone_locations', len(cone_locations.poses))
            # Found the cone.
            self.set_mode(Modes.GUIDED)
            self.drive_to_cone(cone_locations.poses[0])
            self.begin_state(States.DRIVING_TO_CONE)
        elif self.state is States.DRIVING_TO_CONE \
             and len(cone_locations.poses) > 0:
            self.show_event('on_cone_locations', len(cone_locations.poses))
            self.drive_to_cone(cone_locations.poses[0])

    def drive_to_cone(self, cone_pose):
        # A pseudo-distance used to determine the pixel width of a cone
        # heading angle.
        fov_dist = self.camera_horz_pixels/2 / tan(self.camera_horz_fov/2)
        cone_heading = atan2(cone_pose.x, fov_dist)
        distance = self.get_cone_distance(cone_pose.area)

        speed = max(self.cone_approach_k_speed*distance,
                    self.cone_approach_min_speed)
        turning = self.cone_approach_k_heading * cone_heading

        rospy.loginfo('[Navigator] d=%f heading=%f speed=%f turning=%f',
                      distance, cone_heading*180/pi, speed, turning)

        twist = TwistStamped()
        twist.twist.linear.x = speed
        twist.twist.angular.z = turning
        self.vel_pub.publish(twist)

    def get_cone_distance(self, area):
        # Area should be proportional to the square of distance.
        # Assume approx. 3900 pixels at 3 meters and a 2.0
        # aspect ratio.
        ratio = sqrt(3900.0 / area)
        return 3 * ratio

    def set_waypoint_speed(self):
        self.set_speed(self.get_waypoint_speed(self.waypoint_list.current_seq))

    def set_speed(self, speed):
        ## Don't change speed, for now.
        #return

        if speed != self.last_wp_speed:
            value = ParamValue()
            value.real = speed
            self.last_wp_speed = speed
            self.set_mode(Modes.HOLD)
            self._param_set('WP_SPEED', value)
            self.set_mode(Modes.AUTO)
        
    def set_mode(self, mode):
        self._set_mode(0, mode)

    def is_cone_waypoint(self, wp_index):
        wp = self.waypoint_list.waypoints[wp_index]
        return wp.z_alt >= 2000

    def get_waypoint_speed(self, wp_index):
        wp = self.waypoint_list.waypoints[wp_index]
        if wp.z_alt >= 1000:
            return self.slow_speed
        else:
            return self.fast_speed

if __name__ == "__main__":
    try:
        Navigator().run()

    except rospy.ROSInterruptException:
        pass
