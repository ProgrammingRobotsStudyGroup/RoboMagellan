/*! \file wheelencoder.cpp
 *
 * The wheel encoder code.
 */

#pragma once

#include "wheelencoder.h"
#include <stdint.h>

#define hallPin1 0
#define hallPin2 1
#define hallPin3 2
#define hallPin4 3

void magnet_detect();

int value1 = 0;
int value2 = 0;
volatile byte half_revolutions;

static const signed char ENC_STATES [] = {0,1,-1,0,-1,0,0,1,1,0,0,-1,0,-1,1,0};

unsigned int rpm;
unsigned long timeold;
unsigned long lastTime;
//
int pulses;
int pulsesChanged = 0;
int deg = 0;


void initWheelEncoder() {
  Serial.println("Wheel encoder initialized");
  value1 = 0;
  value2 = 0;
  half_revolutions = 0;
  rpm = 0;
  timeold = 0;
  lastTime = millis();

  FastGPIO::Pin<hallPin1>::setInputPulledUp();
  FastGPIO::Pin<hallPin2>::setInputPulledUp();
//  pinMode(hallPin1, INPUT_PULLUP);
//  pinMode(hallPin2, INPUT_PULLUP);
//  pinMode(hallPin3, INPUT_PULLUP);
//  pinMode(hallPin4, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(hallPin1), isrA1, CHANGE);
//  attachInterrupt(digitalPinToInterrupt(hallPin2), isrB1, CHANGE);
//  attachInterrupt(digitalPinToInterrupt(hallPin3), isrA2, CHANGE);
//  attachInterrupt(digitalPinToInterrupt(hallPin4), isrB2, CHANGE);
}

/**
 *
 */
void processWheelEncoder() {
  if (lastTime + 2000 < millis()) {
    Serial.print("Sec: ");
    Serial.println(millis()/1000.0);
    lastTime = millis();
  }
  if (pulsesChanged != 0) {
    pulsesChanged = 0;
    Serial.println(pulses);
  }

//  if (half_revolutions >= 20) { 
//    rpm = 30*1000/(millis() - timeold)*half_revolutions;
//    timeold = millis();
//    half_revolutions = 0;
//    //Serial.println(rpm,DEC);
//  }
}
ISR (PCINT2_vect) {
    Serial.println("ISR");
}

/**
 * 
 */
void isrA1(){
      pulses +=
      (FastGPIO::Pin<hallPin1>::isInputHigh()
       == FastGPIO::Pin<hallPin2>::isInputHigh())
        ? 2
        : -2;

//  int a = digitalRead(hallPin1);
//  int b = digitalRead(hallPin2);
//  if(b == 0 ) {
//    if (a == 0 ) {
//      // A fell, B is low
//      pulses--; // moving reverse
//      Serial.println("B");
//    } else {
//      // A rose, B is low
//      pulses++; // moving forward
//      Serial.println("F");
//    }
// } else {
//    if (a == 0 ) {
//      // A fell, B is high
//      pulses++; // moving forward
//      Serial.println("F");
//    } else {
//      // A rose, B is high
//      pulses--; // moving reverse
//      Serial.println("B");
//    }
//  }
////  // Make sure the pulses are between 0 and 359
////  if (pulses > 359) {
////    pulses = pulses - 360;
////  } else if (pulses < 0) {
////    pulses = pulses + 360;
////  }
 
  // tell the loop that the pulses have changed
  pulsesChanged = 1;
}
void isrB1(){
  int a = digitalRead(hallPin1);
  int b = digitalRead(hallPin2);
  if (a == 0 ) {
    if (b == 0 ) {
      // B fell, A is low
      pulses++; // moving forward
      Serial.println("F");
    } else {
      // B rose, A is low
      pulses--; // moving reverse
      Serial.println("B");
    }
 } else {
    if (b == 0 ) {
      // B fell, A is high
      pulses--; // moving reverse
      Serial.println("B");
    } else {
      // B rose, A is high
      Serial.println("F");
      pulses++; // moving forward
    }
  }
//  // Make sure the pulses are between 0 and 359
//  if (pulses > 359) {
//    pulses = pulses - 360;
//  } else if (pulses < 0) {
//    pulses = pulses + 360;
//  }

  // tell the loop that the pulses have changed
  pulsesChanged = 1;
}
/**
 * Hall sensor ISR 
 */
void magnet_detect() {
  half_revolutions++;
  Serial.print("Detect ");
  if (digitalRead(0) == LOW) {
    Serial.println("LOW");
  }
  else {
    Serial.println("HIGH");
  }
}

